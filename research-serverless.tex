\section{Intro}

% \label{section:serverless-origins}
% - the growth of cloud computing influenced the way how the server applications are developed and how the underlying infrastructure is managed
% - outsourcing the resource management, scaling according to meet the demand and paying proportionally to allocated resources
% - serverless considered as the next step in cloud computing progression - mind shift - no longer thinking in terms of servers, but loosely coupled services, connected with each other to perform some processing, without the need to manage infra
% - seems not to be fully matured technology, but already adopted by various companies and organisations

% \label{section:serverless-definition}
% - no clear definition of serverless
% - don't require server and server apps management, maintenance, provisioning - handled by cloud provider
% - fine grained development, deployment model, multiple components configured to work together
% - platform responsible for provisioning resources, executing, scaling the components to meet the demand
% - billing according to used resources, each of the components billed granularly, no cost when idle - 100 functions running for 1s = 1 function running for 100s

% \label{section:serverless-components}
% - 2 components 
% - BaaS - components replacing some part of server side app, providing some functionality, provides API to integrate with rest of app - existing components like databases, message brokers, or functionalities - authentication, managing emails
% - FaaS - event-driven, ephemeral execution environment executing code iwthin limitted time

% \label{chapter:serverless-benefits-and-challenges}
% - serverless has met with great interest from various architects, devs, companies, noticing numerous advantages
% - benefits: development and operational cost reduction - using BaaS and outsourcing infra, development and operational opportunities, reduing time to market, autoscaling with proportional cost - paying for used resources not allocated, capex -> opex - instead of buing hardware it can be rented according ot needs
% - it also has disadvantages, technology still not fully mature
% - disadvantages: stateless and anonymous function require external components to preserve state, exchange messages - additional overhead, outsourcing brings vendor dependence and due to tight integration vendor lock-in, cold starts due to nature of serverless and no clear performance guarantees, new approach of developing and modeling services, requires some knowledge about patterns and reference architectures to make the processing effective, can't replicate the environemnt locally, need to test after deploying in the cloud, automating the deployment and tests using available tooling to have enough confidence, ensuring monitoring and observability

% \label{chapter:serverless-service-providers}
% - multiple cloud providers embared the serverless paradigm and have different services in their portfolio, enabling developers to build the serverless applications

% \label{chapter:serverless-example-use-cases}
% as for provided examples, serverless is an appropriate solution for building variety of use cases such as 
% - application backend as with CloudGuru example - infra and scaling handled by the platform with proportional billing
% - event-driven data processing - media conversion and transcoding - billing only for the processing time and transferred data
% - real-time data processing, data ingestion task - stream aggregation and processing the collected batch, decoupling services, reliability by storing the messages until the processing entity can pick them up - efficiently processing high-load and high-throughput workloads
% - integration with other devices such as IoT, various services enabling to integrate the external devices with the cloud platform

% \label{chapter:web-apps}
% The second topic tackled in the introduction refers to the web applications, which changed their form over the years, evolving the architecture and development patterns to meet their requirements.

% The idea of World wide Web evolved defining the patterns such as Web Services, Service-Oriented Architecture and REST.

% Different approaches of structuring the backend of the application, along with the evolution of client apps to be more interactive and provide better user experience similar to native applications.

% Backend services becoming more complex, forming loosely coupled distributed services from numerous components serving different purposes - microservices and event-driven architectures

% Different approaches to provide interactive, lightweight and efficient client for apps. -  SPA, different communication protocols

% New approaches to the database systems to meet the amount of data being stored with proper scaling - availability, reliability and performance - new database paradigms and message intermediaries used in the distributed systems

% Different requirements put in front of the client application lead to creating new patterns to meet the requirement put in front of them, including among the others:
% - scalability and performance - how fast the systems responds, how it handles several users performing operations simultaneously, how it copes with the increased load, is performance degradation, lack of availability noticeable
% - reliability - availability of the service, resiliency and fault-tolerance
% - security and compliance - web apps processing more critical and confidential informations - needs to be secured
% - maintenance - monitorin, observability, patching, deployment - the system is running smoothly, from dev perspective - removing complexity, inconsistencies to increase agility

% \subsection{Why AWS}

% \label{chapter:serverless-service-providers}
% - pioneered in the field of serveless, established market position, leading number of services, high quality and constant innovations
% - enterprise ready vendor, most comprehensive infrastructure
% - collection of tooling, making the development more convenient - during the research AWS CDK used to develop the infrastructure in TypeScript along with the AWS SAM used for local testing and debugging of lambdas
% - maturity and variety of services
% - good and broad doccumentation with reference architectures, along with many articles held by practitioners, to figure out the most suitable solutions

\section{Server Tier}

\label{chapter:examples-receipt-processing}
\label{chapter:examples-generating-interactive-slideshow-based-on-latex-files}

\subsection{Lambda function as a compute resource}

\label{chapter:serverless-faas}
- environment for executing the application logic as code
- new approach - development, structuring, packing, deploying - oriented towards individual functions
- cloud providers manage function execution
- strictly limited execution time
- functions runnin in ephemeral containers, ccreated based on runtime needs, destroyed shortly after execution
- invoked based on the events, serverless platform handles resource provisioning, deprovisions resources shortly after - containers reused for the optimisation purposes, forming "warm starts"
- stateless nature, the state is not preserved between the function invocation - requires to preserve it in some external components
- stateless nature makes it easy for horizontal scaling, handled automatically by the cloud provider, executing more functions in parallel when events occur in the system, scaling to zero when no traffic

\subsubsection{Function limitations}

\label{chapter:serverless-processing-limitations-runtime-and-data-restrictions}
- serverless functions - stateless, running inside ephemeral containers, contstrained by the execution itme - horizontal scaling made easier, but requires to preserve the state in some external component, introducing overhead because of using services and communication overhead, no control over container execution - no addresability - message brokers

- runtime restriction of the AWS Lambda - memory, vCPU with multithreading, 900 s execution, payload limit, tmp disc space, deployment package
- running custom execution runtimes, custom container images

\subsubsection{Function runtime} \label{chapter:lambda-custom-runtimes}

- Provisioned Concurrency
- Concurrency limits

\label{chapter:serverless-suitability-processing-time}
- cold start - latencydue to resource provisioning, brings latency and unpredictable response time
- AWS Provisioned Concurrency, programatic solution for Serverless framework

\subsubsection{Function execution model}

\label{section:serverless-function-invocation}
- executing functions in an event-driven approach
- data sources
    - endpoint services - API Gateway, executing function based on requests
    - storage services - BaaS like databaess, file storage, cache services - emitting events based on data change
    - messaging services - data streaming, message brokers, notifications
    - scheduled events - periodic events, cron
- invocation types:
    - synchronous requests - sends request and waits for response, HTTP requests
    - asynchronous message queue requests - events from various data soruces, to some exchange, consumed later
    - event streams - streams of messages - logs, files, sequence of records partitioned into shards
    - batch jobs - splitting task into smaller jobs, processed by multiple functions

\subsubsection{Function optimisations}

\paragraph{Lambda execution}

\paragraph{Lambda configuration}

\label{chapter:serverless-suitability-operation-types}
- using function to transform the data, not to transport the data - services can communicate directly, without incorporating the lambda in the processing
- configure in the event-driven manner - service triggers lambda with the payload to do the processing

\subsection{Serverless processing model}

\subsubsection{Serverless microservices}

\label{section:web-apps-microservices}
- better modularisation 
- scaling, developing and deploying the services independently

- microservices - developing app as a set of smaller, services, communicating with each other via message passing using well defined interfaces, 
- 1 service = 1 business capability - module boundary
- independent deployment, development by independent teams, scaling particular components, not the whole app

- decomposition, maintenance by independent teams - focus on requirements for particular component - independent tools nad language
- service owns its data

- independent deployments - using the automation heavily, CI/CD, increase agility and reduce cycle-time, infra and operational automation
- packed using containers - relocating, replicating services, dynamically alocating new according to the load - staying performant, scaling
- design for failure - robust and fault tolerance, errors inevitable especially in the distributed system - value service contracts, patterns like tolerant reader, circuit breaker - to make the whole system works even wf the components fails
- monitoring, observability, load testing

- for smaller products it may introudce unnecessary complexity
- using asynchronous communication, distributed system, data decentralisation - eahc service owns its data, transactions more complex
- availability desired from the business point of view - transactionless coordination and asynchronous messaging = eventual consistency is ok

- great advantage of developing smaller chunks of app, but managing the whole system is more difficult - embracing automation, DevOps culture

\label{chapter:event-driven-architecture}
- event-driven architecture - richer domain model - DDD good appraoch for separating modules, even for serverless

\label{chapter:event-driven-sourcing}
- serverless does not use the events to preserve them in the database, but uses it to trigger other services to perform its job
- using the mediating mechanism - message bus/message broker - indirect communication between services

\label{chapter:message-brokers}
- decentralised topologies, decoupling the separate stages og the system that communicate with each other
- provide message middleware, capable fo storing, delivering messages to destinations, without knowing if the receivers are available
- quarantee message delivery - storing the messages until consumed by the receiver - prevent loss of data, enables system to run efficiently with connectivity and latency issues
- distribution patterns - point to point, pub-sub based on topics
- microservices - can benefit from scalability and flexibility, due to communication middleware, scaling - increasing number of publishers sor subscribesrs, without affecting others services

https://d1.awsstatic.com/whitepapers/microservices-on-aws.pdf
https://www.jeremydaly.com/serverless-microservice-patterns-for-aws/?utm_source=sidebar

SQS, SNS, Kinesis, ...

\label{chapter:serverless-suitability-operation-types}
- implicit failover - retrying the processing several times - handling the repeated information properly by DLQ, Lambda Destination, idempotent request

\label{chapter:serverless-suitability-cloudguru}
- CloudGuru - splitting the monolithic, serverless architecture using 1 database into multiple parts resembling the microservices approach - different services, ensure proper boundaries, owning its data
- Backend for Frontend pattern - https://microservices.io/patterns/apigateway.html - different endpoint for mobile and web clients based on GraphQL servers hosted in AWs LAmbda - combining repsponse from multiple services
- idependent stacks for stateless (API Gateway, AWS Lambda) and statefull (DynamoDB, S3) components, with common services for all microservices extracted - AWS VPC, AWS WAF, Redshift - losely coupled with different services

\label{chapter:serverless-suitability-temenos}
- more complex system, performing the event sourcing / cqrs processing
- hybrid solution - using the containers (AWS Fargate) and relational databases (AWS RDS) for the processing, while relying on the AWS Lambda and DynamoDB for the asynchronous updates on the read model - high-throughput data ingestion task
- decoupling the processing, providing scalability, incorporating the serverless into larger hybrid solution

\paragraph{Frontend - API Gateway, ...}

\paragraph{Backend - processing ...}

\subsubsection{Function composition and orchestration}

\subsubsection{Redesigning system to leverage benefits of serverless architecture}

\label{chapter:serverless-suitability-utilisation-patterns}
- autoscaling capabilities, tracking load with greater fidelity - suitable for dynamic and irregular workloads
- serverless cost effective for handling unpredictable load, for regular vms could be cheaper - it requires thorough cost estimation - including all of the services, components and work required to maintain the service

\label{chapter:serverless-suitability-processing-time}
- workload can be effectively parallelised, reducing overall processing time

\paragraph{Workload parallelisation}

\label{chapter:serverless-suitability-for-web-based-workloads}
- Yubl - more fine grainer scaling capabilities, compared to containers that tracking the resource utilisation and trigger scaling based on that

\paragraph{Backend for Frontend}

\subsection{Case study - Generating interactive slideshow based on LaTeX files} \label{chapter:latex-processing-optimisation}

\section{Data Tier}

\label{chapter:database-paradigms}
- with the growth of data volumes and its complexity - the relationa database and its scalability reached some limitations with such large amounts of data and at the same time maintain high-availability and fault tolerance
- NoSQL - handling the large amount of data and offering higher availability, but sacrificing the consistency and quering capabilities - tradeoff, less restrictive, dynamic model, support for running in the cluster, providing greater availability and performance

\label{chapter:database-management-tradeoffs}
- level of consistency and database transaction model
- relational database with ACID semantics - consistency over availability
- most of NoSQL - more flexible data model, greater availability, BASE - tolerate small inconsistencies in fabour of greater availability and faster resopnse time
- taking into consideration scaling, distributed systems - there can be various probelms - CAP denotes the upper bound which is achievable in the system in which the nodes or communication channels can fail

\label{chapter:serverless-suitability-operation-types}
- communicating with some external components may require to establish the connection - introduce additional latency
- transformin in a event-driven approach - processing initiated by one function, the service trigers another function with the results, pooling services for data change

\subsection{Suitability of storage services for serverless processing}

\subsection{Serverless databases}

\section{Client Tier}

\subsection{Client communication patterns for serverless architecture}

- communicating with external services directly, bypassing the usage of lambda
https://aws.amazon.com/blogs/compute/from-poll-to-push-transform-apis-using-amazon-api-gateway-rest-apis-and-websockets/

\subsection{Hosting web clients}

% notes.md - Become a Serverless Black Belt - Optimizing Your Serverless Applications